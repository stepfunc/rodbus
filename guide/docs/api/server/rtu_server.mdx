---
id: rtu_server
title: Serial RTU Server
sidebar_label: Serial RTU Server
slug: /api/server/rtu_server
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The library supports serial communication using the RTU transmission mode. RTU uses a similar Modbus addressing scheme but adds
a CRC to each transmitted frame.

Multi-drop communications allow a single client to communicate with multiple servers sharing the same serial channel. Use broadcast messages to write requests simultaneously to all servers on a channel.

## Special addresses

### Broadcast

When a write request is received with the broadcast unit ID (`0x00`), it is automatically forwarded to all registered
handlers. No response will be returned.

### Reserved addresses

Do not use addresses 248 (`0xF8`) to 255 (`0xFF`), which are reserved by the specification. The library does not enforce this requirement but generates a warning as a reminder of potential interoperability issues.

## Creating a server

To create a RTU server, first build a `DeviceMap` for each unit ID to which the server will respond. This is similar to how it is done in the [TCP server](./tcp_server).
Then use the `Server.CreateRtu` factory method to create the background task.

The `Server.CreateRtu` method takes the following arguments:

- `runtime`: tokio runtime used to drive the async process. See [Runtime](../runtime.mdx) for more details.
- `path`: path of the serial device.
  - On Windows, it's generally something like `COM3`
  - On Linux, it's generally something like `/dev/ttyS3`. You need to have the adequate permissions
    to access these devices.
- `serial_port_settings`: structure with various serial port settings:
  - Baud rate in bit per second
  - Data bits. Note that Modbus should use 8 data bits.
  - Stop bits
  - Parity
  - Flow control
- `port_retry_delay`: how long to wait before reopening after a failed open or port error.
- `map`: Map of unit ids and their corresponding callback handlers.
- `level`: Initial decoding level for the port which can be adjusted later via the returned Channel.

:::tip
The task handles dynamic hardware changes, such as USB-to-serial adapter insertion and removal.
:::

<Tabs
groupId="language"
defaultValue="Rust"
values={[
{label: 'Rust', value: 'Rust'},
{label: 'C', value: 'C'},
{label: 'C++', value: 'C++'},
{label: 'Java', value: 'Java'},
{label: 'C#', value: 'C#'},
]}>
<TabItem value="Rust">

```rust
{{#include ../examples/server/src/main.rs:handler_map_create}}

{{#include ../examples/server/src/main.rs:rtu_server_create}}
```

</TabItem>
<TabItem value="C">

```c
{{#include ../ffi/bindings/c/server_example.c:device_map_init}}

{{#include ../ffi/bindings/c/server_example.c:rtu_server_create}}
// check error
```

</TabItem>
<TabItem value="C++">

```cpp
{{#include ../ffi/bindings/c/server_example.cpp:device_map_init}}

{{#include ../ffi/bindings/c/server_example.cpp:rtu_server_create}}
```

</TabItem>
<TabItem value="Java">

```java
{{#include ../ffi/bindings/java/examples/src/main/java/io/stepfunc/rodbus/examples/ServerExample.java:device_map_init}}

{{#include ../ffi/bindings/java/examples/src/main/java/io/stepfunc/rodbus/examples/ServerExample.java:rtu_server_create}}
```

</TabItem>
<TabItem value="C#">

```csharp
{{#include ../ffi/bindings/dotnet/examples/server/Program.cs:device_map_init}}

{{#include ../ffi/bindings/dotnet/examples/server/Program.cs:rtu_server_create}}
```

</TabItem>
</Tabs>
